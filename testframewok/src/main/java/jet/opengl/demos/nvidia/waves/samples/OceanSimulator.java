package jet.opengl.demos.nvidia.waves.samples;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Random;

import org.lwjgl.util.vector.Vector2f;

import jet.opengl.postprocessing.common.GLCheck;
import jet.opengl.postprocessing.common.GLFuncProvider;
import jet.opengl.postprocessing.common.GLFuncProviderFactory;
import jet.opengl.postprocessing.common.GLenum;
import jet.opengl.postprocessing.texture.FramebufferGL;
import jet.opengl.postprocessing.util.CacheBuffer;
import jet.opengl.postprocessing.util.Numeric;

public class OceanSimulator {
	
	private static final float HALF_SQRT_2 = 0.7071068f;
	private static final float GRAV_ACCEL = 981.0f;

	private static final int BLOCK_SIZE_X = 16;
	private static final int BLOCK_SIZE_Y = 16;

	final OceanParameter m_param;
	
	// ---------------------------------- GPU shading asset -----------------------------------
	// Displacement map
	int m_pDisplacementMap;   // RGBA32F
	int m_pDisplacementFBO;
	
	// Gradient field
	int m_pGradientMap;       // RGBA16F
	int m_pGradientFBO;
	
	// ----------------------------------- CS simulation data ---------------------------------

	// Initial height field H(0) generated by Phillips spectrum & Gauss distribution.
	int m_pBuffer_Float2_H0;
	int m_pUAV_H0;
	int m_pSRV_H0;
	
	// Angular frequency
	int m_pBuffer_Float_Omega;
	int m_pUAV_Omega;
	int m_pSRV_Omega;
	
	// Height field H(t), choppy field Dx(t) and Dy(t) in frequency domain, updated each frame.
	int m_pBuffer_Float2_Ht;
	int m_pUAV_Ht;
	int m_pSRV_Ht;
	
	// Height & choppy buffer in the space domain, corresponding to H(t), Dx(t) and Dy(t)
	int m_pBuffer_Float_Dxyz;
	int m_pUAV_Dxyz;
	int m_pSRV_Dxyz;
	
	int m_pQuadVB;
	
	// Shaders, layouts and constants
	OceanSimulatorComputeProgram m_pUpdateSpectrumCS;
	OceanSimulatorProgram m_pSimulatorFX;
	
	// FFT wrap-up
	final FFT.CSFFT512x512_Plan m_fft_plan = new FFT.CSFFT512x512_Plan();
	final Random random = new Random(1015410);
	private GLFuncProvider gl;
	
	public OceanSimulator(String prefix, OceanParameter params) {
		this.m_param = params;
		gl= GLFuncProviderFactory.getGLFuncProvider();
		
		// Height map H(0)
		int height_map_size = (params.dmap_dim + 4) * (params.dmap_dim + 1);
		Vector2f[] h0_data = new Vector2f[height_map_size/* * sizeof(D3DXVECTOR2)*/];  // TODO
		float[] omega_data = new float[height_map_size/* * sizeof(float)*/];  // TODO
		initHeightMap(params, h0_data, omega_data);
		
		int hmap_dim = params.dmap_dim;
		int input_full_size = (hmap_dim + 4) * (hmap_dim + 1);
		// This value should be (hmap_dim / 2 + 1) * hmap_dim, but we use full sized buffer here for simplicity.
		int input_half_size = hmap_dim * hmap_dim;
		int output_size = hmap_dim * hmap_dim;

		// For filling the buffer with zeroes.
		byte[] zero_data = new byte[3 * output_size * /*sizeof(float)*/ 4 * 2];
//					memset(zero_data, 0, 3 * output_size * sizeof(float) * 2);
		
		// RW buffer allocations
		// H0
		int[] buf = new int[2];
		int float2_stride = 2 * /*sizeof(float)*/ 4;
		createBufferAndUAV(/*h0_data*/ buf, CacheBuffer.wrap(h0_data), input_full_size * float2_stride, GLenum.GL_RG32F/*, &m_pBuffer_Float2_H0, &m_pUAV_H0, &m_pSRV_H0*/);
		m_pBuffer_Float2_H0 = buf[0];
		m_pUAV_H0 = m_pSRV_H0 = buf[1];
		// Notice: The following 3 buffers should be half sized buffer because of conjugate symmetric input. But
		// we use full sized buffers due to the CS4.0 restriction.

		// Put H(t), Dx(t) and Dy(t) into one buffer because CS4.0 allows only 1 UAV at a time
		createBufferAndUAV(buf, CacheBuffer.wrap(zero_data), 3 * input_half_size * float2_stride, GLenum.GL_RG32F/*, &m_pBuffer_Float2_Ht, &m_pUAV_Ht, &m_pSRV_Ht*/);
		m_pBuffer_Float2_Ht = buf[0];
		m_pSRV_Ht = m_pUAV_Ht = buf[1];
		
		// omega
		createBufferAndUAV(buf, CacheBuffer.wrapToBytes(omega_data), input_full_size * /*sizeof(float)*/4, GLenum.GL_R32F/*, &m_pBuffer_Float_Omega, &m_pUAV_Omega, &m_pSRV_Omega*/);
		m_pBuffer_Float_Omega = buf[0];
		m_pUAV_Omega = m_pSRV_Omega = buf[1];

		// Notice: The following 3 should be real number data. But here we use the complex numbers and C2C FFT
		// due to the CS4.0 restriction.
		// Put Dz, Dx and Dy into one buffer because CS4.0 allows only 1 UAV at a time
		createBufferAndUAV(buf, CacheBuffer.wrap(zero_data), 3 * output_size * float2_stride, GLenum.GL_RG32F/*, &m_pBuffer_Float_Dxyz, &m_pUAV_Dxyz, &m_pSRV_Dxyz*/);
		m_pBuffer_Float_Dxyz = buf[0];
		m_pUAV_Dxyz = m_pSRV_Dxyz = buf[1];
		
		// D3D11 Textures
		createTextureAndViews(buf, hmap_dim, hmap_dim, GLenum.GL_RGBA32F/*, &m_pDisplacementMap, &m_pDisplacementSRV, &m_pDisplacementRTV*/);
		m_pDisplacementFBO = buf[0];
		m_pDisplacementMap = buf[1];
		createTextureAndViews(buf, hmap_dim, hmap_dim, GLenum.GL_RGBA16F/*, &m_pGradientMap, &m_pGradientSRV, &m_pGradientRTV*/);
		m_pGradientFBO = buf[0];
		m_pGradientMap = buf[1];
		
		// Compute shaders
		m_pUpdateSpectrumCS = new OceanSimulatorComputeProgram(prefix);
		
		// Vertex & pixel shaders
		m_pSimulatorFX = new OceanSimulatorProgram();
		
		// Constant buffers
		int actual_dim = m_param.dmap_dim;
		int input_width = actual_dim + 4;
		// We use full sized data here. The value "output_width" should be actual_dim/2+1 though.
		int output_width = actual_dim;
		int output_height = actual_dim;
		int dtx_offset = actual_dim * actual_dim;
		int dty_offset = actual_dim * actual_dim * 2;
		
		m_pSimulatorFX.enable();
		m_pSimulatorFX.setActualDim(actual_dim);
		m_pSimulatorFX.setInWidth(input_width);
		m_pSimulatorFX.setOutWidth(output_width);
		m_pSimulatorFX.setOutHeight(output_height);
		m_pSimulatorFX.setDxAddressOffset(dtx_offset);
		m_pSimulatorFX.setDyAddressOffset(dty_offset);
		
		m_pUpdateSpectrumCS.enable();
		m_pUpdateSpectrumCS.setActualDim(actual_dim);
		m_pUpdateSpectrumCS.setInWidth(input_width);
		m_pUpdateSpectrumCS.setOutWidth(output_width);
		m_pUpdateSpectrumCS.setOutHeight(output_height);
		m_pUpdateSpectrumCS.setDtxAddressOffset(dtx_offset);
		m_pUpdateSpectrumCS.setDtyAddressOffset(dty_offset);
		
		gl.glUseProgram(0);
		
		FFT.fft512x512_create_plan(m_fft_plan, 3);
	}
	
	// Initialize the vector field.
	// wlen_x: width of wave tile, in meters
	// wlen_y: length of wave tile, in meters
	void initHeightMap(OceanParameter params, Vector2f[] out_h0, float[] out_omega){
		int i, j;
		Vector2f k = new Vector2f();
		
		Vector2f wind_dir = new Vector2f();
		wind_dir.set(params.wind_dir);
		wind_dir.normalise();
		float a = params.wave_amplitude * 1e-7f;	// It is too small. We must scale it for editing.
		float v = params.wind_speed;
		float dir_depend = params.wind_dependency;

		int height_map_dim = params.dmap_dim;
		float patch_length = params.patch_length;

		for (i = 0; i <= height_map_dim; i++)
		{
			// K is wave-vector, range [-|DX/W, |DX/W], [-|DY/H, |DY/H]
			k.y = (-height_map_dim / 2.0f + i) * (2 * Numeric.PI / patch_length);

			for (j = 0; j <= height_map_dim; j++)
			{
				k.x = (-height_map_dim / 2.0f + j) * (2 * Numeric.PI / patch_length);

				float phil = (float) ((k.x == 0 && k.y == 0) ? 0 : Math.sqrt(phillips(k, wind_dir, v, a, dir_depend)));

				if(out_h0[i * (height_map_dim + 4) + j] == null) out_h0[i * (height_map_dim + 4) + j] = new Vector2f();
				out_h0[i * (height_map_dim + 4) + j].x = (float) (phil * random.nextGaussian() * HALF_SQRT_2);
				out_h0[i * (height_map_dim + 4) + j].y = (float) (phil * random.nextGaussian() * HALF_SQRT_2);

				// The angular frequency is following the dispersion relation:
				//            out_omega^2 = g*k
				// The equation of Gerstner wave:
				//            x = x0 - K/k * A * sin(dot(K, x0) - sqrt(g * k) * t), x is a 2D vector.
				//            z = A * cos(dot(K, x0) - sqrt(g * k) * t)
				// Gerstner wave shows that a point on a simple sinusoid wave is doing a uniform circular
				// motion with the center (x0, y0, z0), radius A, and the circular plane is parallel to
				// vector K.
				out_omega[i * (height_map_dim + 4) + j] = (float) Math.sqrt(GRAV_ACCEL * Math.sqrt(k.x * k.x + k.y * k.y));
			}
		}
	}
	
	void updateDisplacementMap(float time){
		// ---------------------------- H(0) . H(t), D(x, t), D(y, t) --------------------------------
		// Compute shader
		m_pUpdateSpectrumCS.enable();
		
		// Buffers
		gl.glBindImageTexture(0, m_pSRV_H0, 0, false, 0, GLenum.GL_READ_ONLY, GLenum.GL_RG32F);
		gl.glBindImageTexture(1, m_pSRV_Omega, 0, false, 0, GLenum.GL_READ_ONLY, GLenum.GL_R32F);
		gl.glBindImageTexture(2, m_pUAV_Ht, 0, false, 0, GLenum.GL_WRITE_ONLY, GLenum.GL_RG32F);
		
		// Uniforms
		m_pUpdateSpectrumCS.setTime(time * m_param.time_scale);
		m_pUpdateSpectrumCS.setChoppyScale(m_param.choppy_scale);
		
		// Run the CS
		int group_count_x = (m_param.dmap_dim + BLOCK_SIZE_X - 1) / BLOCK_SIZE_X;
		int group_count_y = (m_param.dmap_dim + BLOCK_SIZE_Y - 1) / BLOCK_SIZE_Y;
		gl.glDispatchCompute(group_count_x, group_count_y, 1);

		gl.glMemoryBarrier(GLenum.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

		gl.glBindImageTexture(0, 0, 0, false, 0, GLenum.GL_READ_ONLY, GLenum.GL_RG32F);
		gl.glBindImageTexture(1, 0, 0, false, 0, GLenum.GL_READ_ONLY, GLenum.GL_R32F);
		gl.glBindImageTexture(2, 0, 0, false, 0, GLenum.GL_WRITE_ONLY, GLenum.GL_RG32F);
		
		// ------------------------------------ Perform FFT -------------------------------------------
		FFT.fft_512x512_c2c(m_fft_plan, m_pUAV_Dxyz, m_pSRV_Dxyz, m_pSRV_Ht);
		GLCheck.checkError();
		// --------------------------------- Wrap Dx, Dy and Dz ---------------------------------------
		// Push RT
//				int old_viewport_width, old_viewport_height;
//				IntBuffer buf = GLUtil.getCachedIntBuffer(16);
//				GL11.glGetInteger(GL11.GL_VIEWPORT, buf);
//				old_viewport_width = buf.get();
//				old_viewport_height = buf.get();

		int vw,vh;
		IntBuffer vp=CacheBuffer.getCachedIntBuffer(4);
		gl.glGetInteger(GLenum.GL_VIEWPORT, vp);
		vw=vp.get(2);
		vh=vp.get(3);

		// Set RT
		gl.glBindFramebuffer(GLenum.GL_FRAMEBUFFER, m_pDisplacementFBO);
		gl.glViewport(0, 0, m_param.dmap_dim, m_param.dmap_dim);
		gl.glDrawBuffers(GLenum.GL_COLOR_ATTACHMENT0);
		gl.glDisable(GLenum.GL_DEPTH_TEST);
		// VS & PS
		m_pSimulatorFX.enable();  // TODO
//		int bind_program = GL11.glGetInteger(GL20.GL_CURRENT_PROGRAM);
//		System.out.println("bind_program = " + bind_program);
//		System.out.println("m_pSimulatorFX program = " + m_pSimulatorFX.getProgram());
		m_pSimulatorFX.enableUpdateDisplacementPS();
		// Uniforms
		m_pSimulatorFX.setTime(time * m_param.time_scale);
		m_pSimulatorFX.setChoppyScale(m_param.choppy_scale);
		m_pSimulatorFX.setGridLen(m_param.dmap_dim / m_param.patch_length);
		// Buffer resources
//				m_pSimulatorFX.setSamplerDisplacementMap(m_pSRV_Dxyz);
		gl.glBindImageTexture(0, m_pSRV_Dxyz, 0, false, 0, GLenum.GL_READ_ONLY, GLenum.GL_RG32F);
		
//		NvShapes.drawQuad(0);
		gl.glDrawArrays(GLenum.GL_TRIANGLE_STRIP, 0, 4);
		
		// ----------------------------------- Generate Normal ----------------------------------------
		// Set RT
		gl.glBindFramebuffer(GLenum.GL_FRAMEBUFFER, m_pGradientFBO);
		gl.glDrawBuffers(GLenum.GL_COLOR_ATTACHMENT0);
		m_pSimulatorFX.enableGenGradientFoldingPS();
		GLCheck.checkError();
		// Texture resource and sampler
		m_pSimulatorFX.setSamplerDisplacementMap(m_pDisplacementMap);
		gl.glBindSampler(0, OceanSamplers.m_pPointSamplerState);
//		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
//		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
		
//		NvShapes.drawQuad(0);
		gl.glDrawArrays(GLenum.GL_TRIANGLE_STRIP, 0, 4);

		gl.glBindFramebuffer(GLenum.GL_FRAMEBUFFER, 0);
		
//		GL11.glBindTexture(GL11.GL_TEXTURE_2D, m_pGradientMap);
//		GL30.glGenerateMipmap(GL11.GL_TEXTURE_2D);
		gl.glBindTexture(GLenum.GL_TEXTURE_2D, 0);
		gl.glBindSampler(0, 0);
		gl.glViewport(0,0,vw,vh);
	}
	
	// Phillips Spectrum
	// K: normalized wave vector, W: wind direction, v: wind velocity, a: amplitude constant
	static float phillips(Vector2f K, Vector2f W, float v, float a, float dir_depend)
	{
		// largest possible wave from constant wind of velocity v
		double l = v * v / GRAV_ACCEL;
		// damp out waves with very small length w << l
		double w = l / 1000;

		double Ksqr = K.x * K.x + K.y * K.y;
		double Kcos = K.x * W.x + K.y * W.y;
		double phillips = (a * Math.exp(-1.0 / (l * l * Ksqr)) / (Ksqr * Ksqr * Ksqr) * (Kcos * Kcos));

		// filter out waves moving opposite to wind
		if (Kcos < 0)
			phillips *= dir_depend;

		// damp out waves with very small length w << l
		return (float) (phillips * Math.exp(-Ksqr * w * w));
	}
	
	void createBufferAndUAV(int[] buf, Buffer data, int byte_width, int tex_format){
		// Generate a name for the buffer object, bind it to the 
		// GL_TEXTURE_BINDING, and allocate memory for the buffer.
		
		int buffer = gl.glGenBuffer();
		gl.glBindBuffer(GLenum.GL_TEXTURE_BUFFER, buffer);
		if(data != null)
			gl.glBufferData(GLenum.GL_TEXTURE_BUFFER, data, GLenum.GL_DYNAMIC_COPY);
		else
			gl.glBufferData(GLenum.GL_TEXTURE_BUFFER, byte_width, GLenum.GL_DYNAMIC_COPY);
		
		// Generate a new name for texture.
		int texture = gl.glGenTexture();
		// Bind it toe the buffer texture target to create it
		gl.glBindTexture(GLenum.GL_TEXTURE_BUFFER, texture);
		// Attach the buffer object to the texture and specify format
		gl.glTexBuffer(GLenum.GL_TEXTURE_BUFFER, tex_format, buffer);

		gl.glBindTexture(GLenum.GL_TEXTURE_BUFFER, 0);
		gl.glBindBuffer(GLenum.GL_TEXTURE_BUFFER, 0);
		
		buf[0] = buffer;
		buf[1] = texture;
	}
	
	void createTextureAndViews(int[] buf, int width, int height, int format){
		// Create 2D texture
		int texture = gl.glGenTexture();
		gl.glBindTexture(GLenum.GL_TEXTURE_2D, texture);
		gl.glTexStorage2D(GLenum.GL_TEXTURE_2D, 1, format, width, height);
//		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
//		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
//		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
//		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
		gl.glGenerateMipmap(GLenum.GL_TEXTURE_2D);
		int fbo = gl.glGenFramebuffer();
		gl.glBindFramebuffer(GLenum.GL_FRAMEBUFFER, fbo);
		gl.glFramebufferTexture2D(GLenum.GL_FRAMEBUFFER, GLenum.GL_COLOR_ATTACHMENT0, GLenum.GL_TEXTURE_2D, texture, 0);
		
		GLCheck.checkFramebufferStatus(/*fbo*/);

		gl.glBindFramebuffer(GLenum.GL_FRAMEBUFFER, 0);
		gl.glBindTexture(GLenum.GL_TEXTURE_2D, 0);
		
		buf[0] = fbo;
		buf[1] = texture;
	}
	
	public void dispose(){
		if(m_fft_plan.program != 0){
			FFT.fft512x512_destroy_plan(m_fft_plan);
			m_fft_plan.program = 0;
		}
		
		if(m_pBuffer_Float2_H0 != 0){
			gl.glDeleteBuffer(m_pBuffer_Float2_H0);
			m_pBuffer_Float2_H0 = 0;
		}
		
		if(m_pBuffer_Float_Omega != 0){
			gl.glDeleteBuffer(m_pBuffer_Float_Omega);
			m_pBuffer_Float_Omega = 0;
		}
		
		if(m_pBuffer_Float2_Ht != 0){
			gl.glDeleteBuffer(m_pBuffer_Float2_Ht);
			m_pBuffer_Float2_Ht = 0;
		}
		
		if(m_pBuffer_Float_Dxyz != 0){
			gl.glDeleteBuffer(m_pBuffer_Float_Dxyz);
			m_pBuffer_Float_Dxyz = 0;
		}
		
		if(m_pUAV_H0 != 0){
			gl.glDeleteTextures(m_pUAV_H0);
			m_pUAV_H0 = 0;
			m_pSRV_H0 = 0;
		}
		
		if(m_pUAV_Omega != 0){
			gl.glDeleteTextures(m_pUAV_Omega);
			m_pUAV_Omega = 0;
			m_pSRV_Omega = 0;
		}
		
		if(m_pUAV_Ht != 0){
			gl.glDeleteTextures(m_pUAV_Ht);
			m_pUAV_Ht = 0;
			m_pSRV_Ht = 0;
		}
		
		if(m_pUAV_Dxyz != 0){
			gl.glDeleteTextures(m_pUAV_Dxyz);
			m_pUAV_Dxyz = 0;
			m_pSRV_Dxyz = 0;
		}
		
		if(m_pDisplacementMap != 0){
			gl.glDeleteTextures(m_pDisplacementMap);
			gl.glDeleteFramebuffer(m_pDisplacementFBO);
			m_pDisplacementMap = 0;
		}
		
		if(m_pGradientMap != 0){
			gl.glDeleteTextures(m_pGradientMap);
			gl.glDeleteFramebuffer(m_pGradientFBO);
			m_pGradientFBO = 0;
		}
		
		if(m_pUpdateSpectrumCS != null){
			m_pUpdateSpectrumCS.dispose();
			m_pUpdateSpectrumCS = null;
		}
		
		if(m_pSimulatorFX != null){
			m_pSimulatorFX.dispose();
			m_pSimulatorFX = null;
		}
	}

	public int getD3D11DisplacementMap() { return m_pDisplacementMap;}
	public int getD3D11GradientMap() { return m_pGradientMap;}
	
}
